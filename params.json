{"name":"quickmock","tagline":"quickmock is an simple service for automatically injecting mocks into your AngularJS unit tests using Jasmine or Mocha","body":"quickmock\r\n======\r\n\r\nquickmock is a micro-library for initializing, mocking and auto-injecting provider dependencies for Jasmine/Mocha/Chai/Sinon unit tests in AngularJS\r\n\r\n\r\nWhat does it do?\r\n----------------\r\n\r\nMocking out dependencies in unit tests can be a huge pain. Angular makes testing \"easy\", but mocking out *every* dependecy isn't so slick. If you've ever written an Angular unit test (using Jasmine/Mocha), you've probably seen a ton of `beforeEach` boilerplate that looks something like this:\r\n\r\n```javascript\r\ndescribe('zb-toggle Directive', function () {\r\n\t\tvar scope, element, notificationService, $compile;\r\n\r\n\t\tbeforeEach(function(){\r\n\t\t\tmodule('AppModule');\r\n\t\t\tmodule(function($provide){\r\n\t\t\t\tvar mockNotificationService = jasmine.createSpyObj('NotificationService',\r\n\t\t\t\t    ['error','success','warning','basic','confirm']);\r\n\t\t\t\t$provide.value('NotificationService', mockNotificationService);\r\n\t\t\t});\r\n\t\t\tinject(function(_$rootScope_, _$compile_, _NotificationService_){\r\n\t\t\t\tscope = _$rootScope_.$new();\r\n\t\t\t\t$compile = _$compile_;\r\n\t\t\t\tnotificationService = _NotificationService_;\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tbeforeEach(function(){\r\n\t\t\telement = angular.element('<div zb-toggle></div>');\r\n\t\t\t$compile(element)(scope);\r\n\t\t\tscope.$digest();\r\n\t\t});\r\n\r\n\t// ... write actual test cases here\r\n});\r\n```\r\n\r\nThe module containing the directive must first be initialized. Then any dependencies must be mocked out and \"provided\" to the Angular injector. Then `$rootScope`, `$compile` and the mocked service must be injected into your testing environment to be referenced later. Then you have to render, compile and `$digest()` the directive HTML. Once all that is done, you can begin writing test cases.\r\n\r\nWhat if it was a lot easier?  What if we could reduce all of that down to this?\r\n\r\n```javascript\r\ndescribe('zb-toggle Directive', function () {\r\n\t\tvar zbToggle;\r\n\r\n\t\tbeforeEach(function(){\r\n\t\t    zbToggle = quickmock({\r\n\t\t\t\tproviderName: 'zbToggle',\r\n\t\t\t\tmoduleName: 'QuickMockDemo',\r\n\t\t\t\tmockModules: ['QuickMockDemoMocks'],\r\n\t\t\t\thtml: '<div zb-toggle></div>'\r\n\t\t\t});\r\n\t\t\tzbToggle.$compile();\r\n\t\t});\r\n\r\n\t// ... write actual test cases here\r\n});\r\n```\r\n\r\nHow Does It Work?\r\n-----------------\r\n\r\nquickmock does all of that `beforeEach` boilerplate behind the scenes, and returns an object that contains all of the data you need to write your tests. Mocks are defined in their own reusable Angular modules. quickmock then sees which dependencies your provider (i.e. service/factory/directive/filter/controller/etc) has, looks up the mocks for those dependencies, injects them into the provider and into your test, and finally bootstraps all the required modules.\r\n\r\nHow do I use it?\r\n----------------\r\n\r\nLet's start with a simple example. quickmock can work with even the most complex providers, but to start out, we'll choose an easy service that we want to test. Let's say we have the following `'NotificationService'` provider:\r\n\r\n```javascript\r\nangular.module('QuickMockDemo', [])\r\n    .service('NotificationService', ['$window', 'NotificationTitles', function($window, titles){\r\n    \treturn {\r\n    \t\terror: function notificationError(msg){\r\n    \t\t\t$window.alert(titles.error + '\\n\\n' + msg);\r\n    \t\t},\r\n    \t\tsuccess: function notificationSuccess(msg){\r\n    \t\t\t$window.alert(titles.success + '\\n\\n' + msg);\r\n    \t\t},\r\n    \t\twarning: function notificationWarning(msg){\r\n    \t\t\t$window.alert(titles.warning + '\\n\\n' + msg);\r\n    \t\t},\r\n    \t\tbasic: function notificationBasic(msg){\r\n    \t\t\t$window.alert(titles.basic + '\\n\\n' + msg);\r\n    \t\t},\r\n    \t\tconfirm: function notificationConfirm(msg){\r\n    \t\t\treturn $window.confirm(titles.confirm + '\\n\\n' + msg);\r\n    \t\t}\r\n    \t};\r\n    }])\r\n```\r\n\r\nIts a simple service that shows various alert messages to the user, by delegating to `window.alert()`. It has two dependencies: `$window` and `NotificationTitles`, which is looks like this:\r\n\r\n```javascript\r\n.value('NotificationTitles', {\r\n\terror: 'It looks like something went wrong...',\r\n\tsuccess: 'Congraduations!',\r\n\twarning: 'Be careful...',\r\n\tbasic: 'Check this out!',\r\n\tconfirm: 'Confirm Action'\r\n})\r\n```\r\n\r\nWe can test this service by writing the following:\r\n\r\n```javascript\r\ndescribe('NotificationService', function () {\r\n\tvar notificationService;\r\n\r\n\tbeforeEach(function(){\r\n\t\tnotificationService = quickmock({\r\n\t\t\tproviderName: 'NotificationService', // the provider we wish to test\r\n\t\t\tmoduleName: 'QuickMockDemo',         // the module that contains our provider\r\n\t\t\tmockModules: ['QuickMockDemoMocks']  // module(s) that contains mocks for our provider's dependencies\r\n\t\t});\r\n\t});\r\n\t....\r\n```\r\n\r\nquickmock will find the `NotificationService` and lookup its list of dependencies. It will then try to find mocks for each of those dependencies and inject them into your test.\r\n\r\nHow do I write the mocks I need?\r\n--------------------------------\r\n\r\nYou can provide mocks for each of the dependencies by creating a separate javascript file and writing a separate Angular module to contain those mocks. This provides several benefits: it allows your mocks to be reusable between tests, gives you a specific structure for writing your tests, and easily integrates with quickmock.\r\n\r\nquickmock provides a simple syntax for declaring mocks in a module found in [`quickmock.mockHelper.js`](https://github.com/tennisgent/quickmock/blob/master/src/quickmock.mockHelper.js). It allows you to declare mocks as seen in the following simple example:\r\n\r\n```javascript\r\n// Declare an Angular module that will contain any mocks you need\r\nangular.module('SampleMocks', [])\r\n\r\n\t// now declare specific mocks for each of your dependencies\r\n\t.mockService('NotificationService', [function(){\r\n\t\treturn jasmine.createSpyObj('NotificationService', ['error','success','warning','basic','confirm']);\r\n\t}])\r\n\r\n\t.mockFactory('UserFormValidator', [function(){\r\n\t\tvar spy = jasmine.createSpy('UserFormValidator');\r\n\t\tspy.and.returnValue(true);\r\n\t\treturn spy;\r\n\t}])\r\n```\r\n\r\nA detailed explanation of the two possible mock declaration syntaxes (and their advantages and disadvantages) can be found [here](https://github.com/tennisgent/quickmock/tree/master/test/mocks).\r\n\r\nFor further information about how to write specific mocks to acurately mock out your providers, see [this SitePoint article](http://www.sitepoint.com/mocking-dependencies-angularjs-tests/) or the [Angular Developer Guide: Unit Testing](https://docs.angularjs.org/guide/unit-testing).\r\n\r\n\r\nThe quickmock API\r\n-----------------\r\n\r\nAs shown in the example above, a call to quickmock accepts a config object and returns an object, which in this case we called `notificationService`.\r\n\r\n####The Config Object\r\n* `providerName` (String) - The name of the provider you want to test\r\n* `moduleName` (String) - The name of the module that contains the provider above\r\n* `mockModules` (Array:String) - An array of the names of modules that contain mocks for any of the provider's dependencies\r\n* `useActualDependencies` (Boolean) - If quickmock cannot find a mock for a required dependency, it will thrown an exception. If, instead, you wish to delegate to the actual implementations of the dependencies instead of mocking them out, set this flag to `true`.\r\n* `spyOnProviderMethods` (Boolean) - If true, quickmock will automatically spy on the methods of the provider. This will give you access to all of the usual spy functionality for any methods on your provider, but will also call through to the actual implementation so you can test all required functionality. This is very useful when testing certain provider methods that call one another.\r\n* `html` (String|Object) - For directives only, this is the default html that will be compiled when `.$compile()` is called (this is explained below).\r\n\r\n\r\n####The Returned Object\r\nThe `notificationService` object provides all of the data you need to write tests for the `NotificationService` provider.  Here is a walk through of all the information you are given. The following properties are avaiable when testing all provider types (services/factories/directives/controllers/filters/etc):\r\n\r\n* `.$mocks` (Object) - contains all of the mocked dependencies for the provider you are testing\r\n\r\n```javascript\r\n// to test the NotificationService.error() method\r\nit('should display proper error message to the user', function(){\r\n\tnotificationService.error('some fake message'); // calls to the provider\r\n\tvar mock_$window = notificationService.$mocks.$window,\r\n\t    mock_NotificationTitles = notificationService.$mocks.NotificationTitles;\r\n\tvar messageShown = mock_$window.alert.calls.argsFor(0)[0];\r\n\texpect(messageShown).toContain(mock_NotificationTitles.error);\r\n\texpect(messageShown).toContain('some fake message');\r\n});\r\n```\r\n\r\n* `.$initialize()` (Function) - calling .$initialize() will re-initialize the provider you are testing. This is useful if you are testing any functionality that happens at the moment your service is initialized.\r\n\r\nThe following properties are specific to testing `directive` providers and will reference the following example directive:\r\n\r\n```javascript\r\n.directive('zbToggle', ['NotificationService', function(NotificationService){\r\n\treturn {\r\n\t\trestrict: 'AE',\r\n\t\treplace: true,\r\n\t\ttransclude: true,\r\n\t\ttemplate: '<div class=\"toggle\" ng-click=\"check = !check\">'\r\n\t\t\t+ '<input type=\"checkbox\" ng-model=\"check\">'\r\n\t\t\t+ '<span ng-transclude></span>'\r\n\t\t\t+ '</div>',\r\n\t\tscope: {\r\n\t\t\tinitState: '='\r\n\t\t},\r\n\t\tlink: function(scope, elem, attrs){\r\n\t\t\tvar notificationMessage = 'Your preference has been set to: ';\r\n\t\t\tscope.check = scope.initState || false;\r\n\t\t\tscope.$watch('check', function(val){\r\n\t\t\t\tNotificationService[val ? 'success' : 'warning'](notificationMessage + val);\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n}])\r\n```\r\n* `.$compile([html])` (Function) - compiles the given html string/object and calls then `$scope.$digest()`. If no html string/object is given, it will default to the html provided in the config object. You can provide a javascript object, which will be generated into an html string.\r\n\r\n```javascript\r\nit('should compile the given html string', function(){\r\n\tzbToggle.$compile('<div zb-toggle class=\"btn btn-round\" init-state=\"true\"></div>');\r\n\texpect(zbToggle.$element[0].tagName).toEqual('DIV');\r\n\texpect(zbToggle.$element.hasClass('btn-round')).toEqual(true);\r\n\texpect(zbToggle.$scope.initState).toEqual(true);\r\n\tzbToggle.$compile('<span zb-toggle class=\"btn btn-shadow\" init-state=\"false\"></span>');\r\n\texpect(zbToggle.$element[0].tagName).toEqual('SPAN');\r\n\texpect(zbToggle.$element.hasClass('btn-shadow')).toEqual(true);\r\n\texpect(zbToggle.$scope.initState).toEqual(false);\r\n});\r\n\r\nit('should compile the given html object', function(){\r\n\tvar htmlObj = {\r\n\t\t$tag: 'div',  \t\t\t// $tag (required): will be the html tagName (i.e. '<zb-toggle ...>' or '<div ...>' or '<span ...>')\r\n\t\t$content: '',  \t\t\t// $content (optional): will be inner content of the html element\r\n\t\tzbToggle: '',\r\n\t\tclass: 'btn btn-round',\r\n\t\tinitState: true\t\t\t// properties are normalized (i.e. 'initState: true' will become 'init-state=\"true\"')\r\n\t};\r\n\tzbToggle.$compile(htmlObj);\r\n\texpect(zbToggle.$element[0].tagName).toEqual('DIV');\r\n\texpect(zbToggle.$element.hasClass('btn-round')).toEqual(true);\r\n\texpect(zbToggle.$scope.initState).toEqual(true);\r\n\thtmlObj.$tag = 'span';\r\n\thtmlObj.class = 'btn btn-shadow';\r\n\thtmlObj.initState = false;\r\n\tzbToggle.$compile(htmlObj);\r\n\texpect(zbToggle.$element[0].tagName).toEqual('SPAN');\r\n\texpect(zbToggle.$element.hasClass('btn-shadow')).toEqual(true);\r\n\texpect(zbToggle.$scope.initState).toEqual(false);\r\n});\r\n```\r\n\r\n* `.$element` (jQuery/jqLite Element) - provides access to the element that results from `angular.element()`.\r\n\r\n```javascript\r\nit('should have the toggle class', function(){\r\n\texpect(zbToggle.$element.hasClass('toggle')).toBe(true);\r\n});\r\n\r\nit('should show a checkbox', function(){\r\n\tvar input = zbToggle.$element.find('input');\r\n\texpect(input.attr('type')).toEqual('checkbox');\r\n});\r\n```\r\n\r\n* `.$scope` (Object) - provides access to the directive's Angular `scope` object\r\n\r\n```javascript\r\nit('should toggle the checkbox when clicked', function(){\r\n\texpect(zbToggle.$scope.check).toBe(false);\r\n\tzbToggle.$element[0].click();\r\n\texpect(zbToggle.$scope.check).toBe(true);\r\n\tzbToggle.$element[0].click();\r\n\texpect(zbToggle.$scope.check).toBe(false);\r\n});\r\n\r\nit('should show a success message when toggled to true', function(){\r\n\texpect(zbToggle.$scope.check).toBe(false);\r\n\tzbToggle.$scope.check = true;\r\n\tzbToggle.$scope.$digest();\r\n\texpect(zbToggle.$mocks.NotificationService.success).toHaveBeenCalled();\r\n});\r\n```\r\n\r\n\r\n* `.$isoScope` (Object) - provides access to the directive's Angular `isoloateScope` object, if one exists\r\n\r\n```javascript\r\nit('should have an isolateScope', function(){\r\n\texpect(zbToggle.$isoScope).toBe(zbToggle.$element.isolateScope());\r\n});\r\n```\r\n\r\nMore In-depth Examples\r\n----------------------\r\n\r\nThe examples above are very simple. You will find more in-depth examples for each of the various provider types in the [`demo/app.js`]('https://github.com/tennisgent/QuickMock/blob/master/demo/app.js') file. Each of the providers in that file have their own quickmock test files that give more details on how to test them using quickmock. Each of these specs files are found in the [`specsUsingQuickMock`](https://github.com/tennisgent/quickmock/tree/master/test/specsUsingQuickMock) folder.\r\n\r\n| Type  | Name | Spec File |\r\n| ------------- | ------------- | ------------- |\r\n| `service`  | `APIService` | [`apiService.spec.js`](https://github.com/tennisgent/quickmock/blob/master/test/specsUsingQuickMock/apiService.spec.js) |\r\n| `factory`  | `UserFormValidator` | [`userFormValidatorService.spec.js`](https://github.com/tennisgent/quickmock/blob/master/test/specsUsingQuickMock/userFormValidatorService.spec.js) |\r\n| `service`  | `NotificationService` | [`notificationService.spec.js`](https://github.com/tennisgent/quickmock/blob/master/test/specsUsingQuickMock/notificationService.spec.js) |\r\n| `controller`  | `FormController` | [`formController.spec.js`](https://github.com/tennisgent/quickmock/blob/master/test/specsUsingQuickMock/formController.spec.js) |\r\n| `directive`  | `zb-toggle` | [`zbToggleDirective.spec.js`](https://github.com/tennisgent/quickmock/blob/master/test/specsUsingQuickMock/zbToggleDirective.spec.js) |\r\n| `filter`  | `firstInitialLastName` | [`firstInitialLastNameFilter.spec.js`](https://github.com/tennisgent/quickmock/blob/master/test/specsUsingQuickMock/firstInitialLastNameFilter.spec.js) |\r\n\r\nFor those who are curious, there are also examples of testing these same providers **without** using quickmock for comparison. These specs are found in the [`specsWithoutUsingQuickMock`](https://github.com/tennisgent/quickmock/tree/master/test/specsWithoutUsingQuickMock) folder.\r\n\r\nYou will also find example mocks for each of these providers, as well as mocks the angular `$promise`, `$http` and `$scope` services in the [`mocksModule.js`](https://github.com/tennisgent/quickmock/blob/master/test/mocksModule.js) file.\r\n\r\n\r\nConfig and Run Blocks\r\n---------------------\r\n\r\nIn order to retrieve the list of dependencies for any given provider, quickmock has to instantiate the angular modules provided in the `moduleName` and `mockModules` properties of the config object. These modules are instantiated the moment `quickmock({...})` is called. (Traditionally, this was done in `beforeEach` blocks using the `module()` method provided in the `ngMock` module.) As a side effect of this pre-instantiation, all `.config()` and `.run()` blocks declared in those modules will be run at that moment. So any code in those blocks will also be executed.\r\n\r\nAs a rule, quickmock does not inject mocked versions of any of the dependencies for a `.config` or `.run` block. So these code blocks will receive the actual implemenations of the services/providers they depend on so that the code in these blocks will function as expected. If anyone would like to see this changed, please submit an issue and it can be discussed.\r\n\r\nIf you wish to test code in a `.config()` or a `.run()` block, it is recommended that you not use quickmock. Instead, simply call angular's `module('myModule')` function, which will instantiate the `myModule` module and execute these code blocks.\r\n\r\n\r\nInstalling\r\n----------\r\n\r\n```\r\nnpm install quickmock\r\n```\r\n\r\nTesting Frameworks\r\n------------------\r\n\r\nAs mentioned above, quickmock works with most of the popular JavaScript unit testing frameworks. It has been tested with Jasmine 1.3+, Mocha 2.0+, Sinon.js, Chai.js. It is expected to work with nearly any others. The exception to this rule is with the `spyOnProviderMethods: true` config option. This option only works with Jasmine and with Mocha (when using sinon.js).\r\n\r\nRunning the Tests\r\n-----------------\r\n\r\n####Karma:\r\nAn example karma config file can be found [here](https://github.com/tennisgent/quickmock/blob/master/test/karma.conf.js). You will need to include the following `files` in your karma config file:\r\n```javascript\r\nfiles: [\r\n    'vendor/angular.js',\r\n    'vendor/angular-mocks.js',\r\n    'vendor/quickmock.js',\r\n    '<source code>.js',\r\n    '<test specs>.js',\r\n    '<any file(s) containing mocks>.js'\r\n]\r\n```\r\n####Jasmine Spec Runner\r\nIn the `<head>` of the SpecRunner.html file, you will need to include references to the following files:\r\n\r\n```html\r\n<!-- include vendor files here... -->\r\n<script src=\"vendor/angular.js\"></script>\r\n<script src=\"vendor/angular-mocks.js\"></script>\r\n<script src=\"vendor/quickmock.js\"></script>\r\n\r\n<!-- include source files here... -->\r\n<script src=\"<source code>.js\"></script>\r\n\r\n<!-- include spec files here... -->\r\n<script src=\"<test specs>.js\"></script>\r\n```\r\n\r\nIdeas for Improvement?\r\n----------------------\r\nIf you have any ideas for how to make quickmock better, please submit them as pull requests.\r\n\r\nIssues?\r\n-------\r\nIf you find any issues or bugs, please submit them as issues on this repository.\r\n","google":"UA-59390848-1","note":"Don't delete this file! It's used internally to help with page regeneration."}